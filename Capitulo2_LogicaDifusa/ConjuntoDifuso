//la clase mas importante tanto a nivel de c贸digo como a nivel  de funcinoalidad
//pues es la que comtrola el sistema difuso
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.StringJoiner;

public class ConjuntoDifuso{
    protected ArrayList<Punto2D> puntos;
    protected double min;
    protected double max;

    //constructor
    public ConjuntoDifuso(double _min, double _max){
        puntos = new ArrayList();
        min = _min;
        max= _max;
    }
    //agregar un punto
    public void Agregar(Punto2D pt){
        puntos.add(pt);
        Collections.sort(puntos);
    }

    public void Agregar(double x, double y){
        Punto2D pt=new Punto2D(x,y);
        Agregar(pt);
    }
    //metodo toString quemuestra el intervalo de valores y los distintos puntos registrados en el sisteam
    @Override
    public String toString(){
        StringJoiner sj=new StringJoiner(" ");
        sj.add("["+min+"-"+max+"]:");
        for( Punto2D pt:puntos){
            sj.add(pt.toString());
        }
        return sj.toString();
    }

    //operador de comparacion(/comapracion de cadenas)
    @Override
    public boolean equals(Object pt2){
        return toString().equals(((Punto2D)pt2).toString());
    }
    //operador de multiplicacion
    public ConjuntoDifuso MultiplicarPor(double valor){
        ConjuntoDifuso conjunto=new ConjuntoDifuso(min,max);
        for(Punto2D pt:puntos){
            conjunto.Agregar(pt.x,pt.y*valor);
        }
        return conjunto;
    }
    //codificamos el operador NOT
    public ConjuntoDifuso No(){
        ConjuntoDifuso conjunto=new ConjuntoDifuso(min,max);
        for(Punto2D pt: puntos){
            conjunto.Agregar(pt.x,1-pt.y);
        }
        return conjunto;
    }
    /*para el siguietne metdoo debemos complciarlo mas ya que tenemos que determinar un GRADO DE PERTENENCIA
    , necesario para la fuzzificaci贸n.
    Tres Casos
        1.Valor fuera del intervalo: grado pertenencia nulo
        2.existe un valor para este pnto dentro del conjunto difuso: devolvemos el grado registrado
        3. no hay definido ningun punto para este valor, interpolamos el grado de pertenencia. Necesitamos
            el punto inmediatamente anterior y el punto inmediatamente posterior
    */
   //calculamos el grado de pertenencia de un punto
   public double ValorDePertenencia(double valor){
    //vaso1: al exterior del intervalo del conjunto difuso
    if(valor < min || valor || max || puntos.size()<2){
        return 0;
    } 
    Punto2D ptAntes= puntos.get(0);
    Punto2D ptDespues=puntos.get(1);
    int index=0;
    while(valor>=ptDespues.x){
        index++;
        ptAntes=ptDespues;
        ptDespues=puntos.get(index);
    }
    if (ptAntes.x==valor){
        //tenemos un punto para este valor
        return ptAntes.y;
    }
    else{
        //se aplica la interpolacion
        return ((ptAntes.y-ptDespues.y)*(ptDespues.x-valor)/(ptDespues.x-ptAntes.x)+ptDespues.y);
    }
   }
   //los metodos de arriba permiten calcular la intersecci贸n y la uni贸n de los conjuntos difusos, los operadores AND (&) y OR(||),
   //siendo operadores de Zadeh
}